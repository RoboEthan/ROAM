// =============================================================
// ESP32-S3 — Dual-core diagnostics (USB Serial + Pi UART + SIM7600)
// Core 0: Pi UART + motors (PWM) + line-by-line JSON processing
// Core 1: SIM7600 modem (GPS + HTTP POST) triggered by categories
//
// Key steering behavior (your rule set):
//   - Deadband: L ∈ [-10, +10] --> LEFT = 20%, RIGHT = 20%
//   - L > 10  (turn RIGHT):
//       RIGHT = (20% of 255 ≈ 51) + |L|   (clamped at 255)
//       LEFT  = max(0, 51 - |L|)          // never reverse
//   - L < -10 (turn LEFT):
//       LEFT  = (20% of 255 ≈ 51) + |L|   (clamped at 255)
//       RIGHT = max(0, 51 - |L|)          // never reverse
// =============================================================

#include <Arduino.h>
#include <HardwareSerial.h>
#include <math.h>

SemaphoreHandle_t gSerialMtx = nullptr;

// UART pinout
#define PI_RX_PIN   44
#define PI_TX_PIN   43
#define PI_BAUD     115200

#define MODEM_TX    17
#define MODEM_RX    18
#define MODEM_BAUD  115200
#define APN "wholesale"
#define URL "https://roambot.dev/data"

HardwareSerial modem(2);

// Motor pins
#define L_DIR 19
#define L_PWM 8
#define R_DIR 10
#define R_PWM 9

#define LEFT_PWM_PIN   L_PWM
#define RIGHT_PWM_PIN  R_PWM
#define LEFT_EN_PIN    L_DIR
#define RIGHT_EN_PIN   R_DIR

const bool LEFT_ACTIVE_LOW  = false;
const bool RIGHT_ACTIVE_LOW = false;

const int MAX_DUTY = 255;
static char   lineBuf[256];
static size_t lineLen = 0;
static int  currentLeftDuty  = 0;
static int  currentRightDuty = 0;
static TaskHandle_t modemTaskHandle = nullptr;

// ---------- Safe Serial print helpers ----------
void sp(const char* s){
  if(gSerialMtx) xSemaphoreTake(gSerialMtx, portMAX_DELAY);
  Serial.print(s);
  if(gSerialMtx) xSemaphoreGive(gSerialMtx);
}

void spln(const char* s){
  if(gSerialMtx) xSemaphoreTake(gSerialMtx, portMAX_DELAY);
  Serial.println(s);
  if(gSerialMtx) xSemaphoreGive(gSerialMtx);
}

void spf(const char* fmt, ...){
  if(gSerialMtx) xSemaphoreTake(gSerialMtx, portMAX_DELAY);
  va_list ap;
  va_start(ap, fmt);
  Serial.vprintf(fmt, ap);
  va_end(ap);
  if(gSerialMtx) xSemaphoreGive(gSerialMtx);
}

// ---------- PWM helpers ----------
// Write a (linear) duty to a PWM pin, honoring active-low polarity.
static inline void pwmWritePin(int pin, int duty_linear_0_255, bool activeLow){
  duty_linear_0_255 = constrain(duty_linear_0_255, 0, 255);
  uint8_t duty = (uint8_t)duty_linear_0_255;
  if(!activeLow) duty = 255 - duty;
  analogWrite(pin, duty);
}

void leftSetDuty (int d){
  d = constrain(d, 0, MAX_DUTY);
  pwmWritePin(LEFT_PWM_PIN, d, LEFT_ACTIVE_LOW);
  currentLeftDuty = d;
  spf("[LEFT] duty=%d (RIGHT=%d)\n", currentLeftDuty, currentRightDuty);
}

void rightSetDuty(int d){
  d = constrain(d, 0, MAX_DUTY);
  pwmWritePin(RIGHT_PWM_PIN, d, RIGHT_ACTIVE_LOW);
  currentRightDuty = d;
  spf("[RIGHT] duty=%d (LEFT=%d)\n", currentRightDuty, currentLeftDuty);
}

void stopBoth(){
  leftSetDuty(0);
  rightSetDuty(0);
  spln("[MOTOR] Stop BOTH (PWM=0, enables held ON)");
}

// ---------- Steering mapper ----------
static inline void applySteering(long Lraw){
  const int DEADBAND = 10;
  const int MAXPWM   = 255;
  const int BASEPWM  = (int)roundf(0.20f * MAXPWM); // ~51

  int L = (int)constrain(Lraw, -255L, 255L);
  int delta = abs(L);

  if (L > 10){
    int right = BASEPWM + delta; if (right > MAXPWM) right = MAXPWM;
    int left  = BASEPWM - delta; if (left  < 0)      left  = 0;
    leftSetDuty(left);
    rightSetDuty(right);

  } else if (L < -10) {
    int left  = BASEPWM + delta; if (left  > MAXPWM) left  = MAXPWM;
    int right = BASEPWM - delta; if (right < 0)      right = 0;
    leftSetDuty(left);
    rightSetDuty(right);

  } else {
    leftSetDuty(BASEPWM);
    rightSetDuty(BASEPWM);
  }
}

// ---------- JSON parsing ----------
void handleJsonLine(const char* s);
bool parseCategory(const char* s, char &outCat);
bool parseLValue(const char* s, long &outVal);

// ---------- Modem helper ----------
String sendAT(const String &cmd, uint32_t timeout=10000, const char *waitFor=nullptr){
  modem.println(cmd);
  sp(">> "); spln(cmd.c_str());
  String resp;
  uint32_t start=millis();
  while(millis()-start < timeout){
    while(modem.available()) resp += (char)modem.read();
    if(waitFor && resp.indexOf(waitFor)!=-1) break;
    if(resp.indexOf("+HTTPACTION:")!=-1) break;
    vTaskDelay(pdMS_TO_TICKS(50));
  }
  if(resp.length()) spln(resp.c_str());
  return resp;
}

// ---------- Core 0: Pi + Motors ----------
void piMotorTask(void*){
  for(int i=0;i<3;i++){
    spln("[CORE0] booting piMotorTask...");
    vTaskDelay(pdMS_TO_TICKS(200));
  }

  Serial1.begin(PI_BAUD, SERIAL_8N1, PI_RX_PIN, PI_TX_PIN);
  while (Serial1.available()) Serial1.read();

  pinMode(LEFT_EN_PIN,  OUTPUT);
  pinMode(RIGHT_EN_PIN, OUTPUT);

  // Always enable both motors (active-HIGH assumed)
  digitalWrite(LEFT_EN_PIN,  HIGH);
  digitalWrite(RIGHT_EN_PIN, HIGH);

#if defined(ARDUINO_ARCH_ESP32)
  // Set per-pin resolution + frequency
  analogWriteResolution(LEFT_PWM_PIN,  8);
  analogWriteResolution(RIGHT_PWM_PIN, 8);
  analogWriteFrequency(LEFT_PWM_PIN,  8000);
  analogWriteFrequency(RIGHT_PWM_PIN, 8000);
#endif

  stopBoth();
  spln("[CORE0] READY: JSON at 115200 on RX=44/TX=43");

  for(;;){
    while (Serial1.available()){
      char c = (char)Serial1.read();
      if (c=='\r') continue;
      if (c=='\n'){
        lineBuf[min(lineLen, sizeof(lineBuf)-1)] = '\0';
        if(lineLen>0){
          sp("[PI->ESP32] ");
          spln(lineBuf);
          handleJsonLine(lineBuf);
        }
        lineLen = 0;
      }else{
        if (lineLen < sizeof(lineBuf)-1) lineBuf[lineLen++] = c;
        else lineLen = 0;
      }
    }
    vTaskDelay(pdMS_TO_TICKS(5));
  }
}

// ---------- Core 1: SIM7600 ----------
float parseCoord(const String &coord, const String &dir){
  if (coord.length() < 4) return NAN;
  if (coord == "" || coord == "0" || coord == "0.0") return NAN;
  float v = coord.toFloat(); if (!isfinite(v)) return NAN;
  int deg = (int)floorf(v / 100.0f);
  float min = v - (deg * 100.0f);
  float dd = deg + (min / 60.0f);
  if (dir == "S" || dir == "W") dd = -dd;
  return dd;
}

bool getGPS(float &lat, float &lon){
  String resp = sendAT("AT+CGPSINFO", 5000);
  int idx = resp.indexOf("+CGPSINFO:"); if(idx==-1) return false;
  String data = resp.substring(idx+10); data.trim();
  if (data.startsWith(",")) return false;
  String t[8]; int last=0,c=0;
  for(int i=0;i<data.length() && c<8;i++){
    if(data[i]==','||data[i]=='\n'||data[i]=='\r'){
      t[c++]=data.substring(last,i);
      last=i+1;
    }
  }
  if(c<4) return false;
  lat = parseCoord(t[0], t[1]);
  lon = parseCoord(t[2], t[3]);
  return (lat!=0 && lon!=0);
}

void modemTask(void*){
  modem.begin(MODEM_BAUD, SERIAL_8N1, MODEM_RX, MODEM_TX);
  vTaskDelay(pdMS_TO_TICKS(1500));
  spln("[CORE1] modemTask start");
  sendAT("AT"); sendAT("ATE0"); sendAT("AT+CPIN?"); sendAT("AT+CSQ");
  sendAT("AT+CGATT=1", 10000);
  sendAT("AT+CGDCONT=1,\"IP\",\"" APN "\"");
  sendAT("AT+CGPADDR=1");
  sendAT("AT+CGPS=0",1500);
  sendAT("AT+CGPS=1",5000);
  sendAT("AT+HTTPTERM");
  sendAT("AT+HTTPINIT");
  sendAT("AT+HTTPPARA=\"CID\",1");
  sendAT("AT+HTTPPARA=\"CONTENT\",\"application/json\"");
  sendAT("AT+HTTPPARA=\"URL\",\"" URL "\"");
  sendAT("AT+HTTPSSL=1");
  const uint32_t MIN_POST_GAP_MS=3000;
  uint32_t lastPostMs=0;

  for(;;){
    ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
    spln("[CORE1] trigger -> getting GPS...");
    uint32_t now=millis();
    if(now-lastPostMs<MIN_POST_GAP_MS){
      spln("[CORE1] debounce");
      continue;
    }
    float lat=NAN,lon=NAN;
    for(int i=0;i<8&&(isnan(lat)||isnan(lon));++i){
      if(getGPS(lat,lon)) break;
      vTaskDelay(pdMS_TO_TICKS(1000));
    }
    if(isnan(lat)||isnan(lon)){
      spln("[CORE1] WARN: No fix");
      lat=0; lon=0;
    }
    String body="{\"lat\":"+String(lat,6)+",\"lon\":"+String(lon,6)+"}";
    spf("[CORE1] POST %s\n",body.c_str());
    auto postOnce=[&](){
      int len=body.length();
      String r=sendAT("AT+HTTPDATA="+String(len)+",10000",5000,"DOWNLOAD");
      if(r.indexOf("DOWNLOAD")==-1)return false;
      modem.print(body);
      vTaskDelay(pdMS_TO_TICKS(300));
      r=sendAT("AT+HTTPACTION=1",15000,"+HTTPACTION:");
      if(r.indexOf("+HTTPACTION:")==-1)return false;
      sendAT("AT+HTTPREAD",5000);
      return true;
    };
    if(!postOnce()){
      spln("[CORE1] HTTP error; reinit");
      sendAT("AT+HTTPTERM");
      sendAT("AT+HTTPINIT");
      sendAT("AT+HTTPPARA=\"CID\",1");
      sendAT("AT+HTTPPARA=\"CONTENT\",\"application/json\"");
      sendAT("AT+HTTPPARA=\"URL\",\"" URL "\"");
      sendAT("AT+HTTPSSL=1");
      postOnce();
    }
    lastPostMs=millis();
  }
}

// ---------- JSON handlers ----------
void handleJsonLine(const char* s){
  while(*s==' '||*s=='\t') s++;
  size_t n=strlen(s);
  while(n&&(s[n-1]==' '||s[n-1]=='\t')) n--;
  if(n==0||s[0]!='{'||strchr(s,'}')==nullptr){
    spln("[WARN] Not JSON");
    return;
  }

  char cat;
  if(parseCategory(s,cat)){
    if(cat=='T'||cat=='G'){
      spf("[RX] CATEGORY: %c -> notify modem\n", cat);
      if(modemTaskHandle) xTaskNotifyGive(modemTaskHandle);
    }
  }

  long L;
  if(parseLValue(s,L)){
    spf("[RX] L=%ld\n",L);
    applySteering(L);
  }
}

bool parseLValue(const char* s,long &outVal){
  const char* k=strstr(s,"\"L\""); if(!k)return false;
  const char* c=strchr(k,':'); if(!c)return false;
  const char* p=c+1; while(*p==' '||*p=='\t')p++;
  bool neg=false; if(*p=='-'){neg=true;p++;}else if(*p=='+'){p++;}
  if(*p<'0'||*p>'9')return false;
  long v=0; while(*p>='0'&&*p<='9'){v=v*10+(*p-'0');p++;}
  outVal=neg?-v:v; return true;
}

bool parseCategory(const char* s,char &outCat){
  const char* k=strstr(s,"\"C\""); if(!k)return false;
  const char* c=strchr(k,':'); if(!c)return false;
  const char* p=c+1; while(*p==' '||*p=='\t')p++;
  if(*p!='\"')return false; p++;
  if(!*p)return false;
  outCat=*p; return true;
}

// ---------- Arduino setup ----------
void setup(){
  Serial.begin(115200);
  uint32_t t0=millis();
  while((millis()-t0)<1500&&!Serial){ delay(50); }
  Serial.println("\n[BOOT] setup() starting");
  gSerialMtx=xSemaphoreCreateMutex();
  if(!gSerialMtx) Serial.println("[BOOT] WARN: mutex create failed");

  xTaskCreatePinnedToCore(piMotorTask,"piMotorTask",4096,NULL,2,NULL,0);
  xTaskCreatePinnedToCore(modemTask,"modemTask",8192,NULL,2,&modemTaskHandle,1);
  Serial.println("[BOOT] tasks created");
}

void loop(){}
